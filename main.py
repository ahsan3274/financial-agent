"""
/main.py
Main execution script for the Financial Agent system.
Initializes components, loads initial data, defines tools, and runs the agent.
"""
import os
import pandas as pd
import logging
import json 
from agent.core import FinancialAgent
from agent.self_improvement import SelfImprovementEngine
from memory.long_term import LongTermMemory
from tools.budget_advisor import BudgetAdvisor
from tools.category_manager import CategoryManager
from tools.data_analyzer import DataAnalyzer
from tools.goal_tracker import GoalTracker
from utils.llm_utils import LLMManager
from typing import Optional


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def load_expenses_from_csv(long_term_memory: LongTermMemory, category_manager: CategoryManager, csv_path: str):
    """Loads expense data from a CSV file into LongTermMemory."""
    logger.info(f"Attempting to load synthetic expenses from {csv_path}")

    if not os.path.exists(csv_path):
        logger.warning(f"CSV file not found: {csv_path}. No expenses loaded.")
        return

    try:
        posting_date_col = 'Posting date'
        amount_col = 'Amount'
        payee_col = 'Payee'
        payment_method_col = 'Payment Method'
        category_col = 'Category' # Column with PRE-DEFINED category

        df = pd.read_csv(
            csv_path,
            converters={amount_col: lambda x: str(x).replace(',', '.')},
            dtype={
                payee_col: str,
                payment_method_col: str,
                category_col: str,
            },
            parse_dates=[posting_date_col], 
            dayfirst=False, 
            on_bad_lines='warn'
        )
        logger.info(f"Loaded {len(df)} rows from CSV '{csv_path}'.")

        expenses_added = 0
        for index, row in df.iterrows():
            try:
                
                amount_val = pd.to_numeric(row.get(amount_col), errors='coerce')
                if pd.isna(amount_val):
                    logger.warning(f"Skipping row {index} due to unparseable amount: {row.get(amount_col)}")
                    continue
                amount = float(amount_val) # Already includes sign +/-

                
                date_obj = row.get(posting_date_col)
                if pd.isna(date_obj):
                    logger.warning(f"Skipping row {index} due to unparseable date.")
                    continue

                
                description = str(row.get(payee_col, 'Unknown Payee')).strip()
                if not description: # Handle empty Payee
                    description = "Unknown Payee"

              
                payment_method = str(row.get(payment_method_col, '')).strip()

            
                category = str(row.get(category_col, 'Uncategorized')).strip()
                if not category: # Handle empty Category
                    category = 'Uncategorized' # Or 'Other' if that's your default

               
                expense_record = {
                    'date': date_obj,
                    'description': description,
                    'amount': amount, # Keep original sign
                    'category': category, # Use category from CSV
                    'notes': '', # Add notes if your synthetic data has them
                    'subcategory': None, # Not available
                    'payment_method': payment_method if payment_method else None # Use extracted or None
                    # id will be generated by ltm.add_expense
                }

                long_term_memory.add_expense(expense_record)
                expenses_added += 1

            except Exception as row_error:
                 logger.error(f"Error processing row {index} from CSV: {row_error}", exc_info=False)

        logger.info(f"Successfully processed and added {expenses_added} transactions to long-term memory.")

    except FileNotFoundError:
        logger.error(f"Error: Input file '{csv_path}' not found.")
    except ValueError as ve:
        logger.error(f"ValueError loading or processing CSV '{csv_path}': {str(ve)}", exc_info=False)
    except Exception as e:
        logger.error(f"General error loading or processing CSV '{csv_path}': {str(e)}", exc_info=True)

# --- initialize_agent function (keep as is) ---
def initialize_agent():
    """Initializes all components of the financial agent system."""
    logger.info("Initializing agent...")

    data_dir = "data"
    os.makedirs(data_dir, exist_ok=True)
    transactions_dir = os.path.join(data_dir, "transactions")
    os.makedirs(transactions_dir, exist_ok=True)

    llm_manager = LLMManager()
    long_term_memory = LongTermMemory(data_dir=data_dir)

    category_manager = CategoryManager(
        storage_path=os.path.join(data_dir, "categories_rules.json"),
        llm_manager=llm_manager
    )
    budget_advisor = BudgetAdvisor(budget_file=os.path.join(data_dir, "budget.json"))
    goal_tracker = GoalTracker(storage_path=os.path.join(data_dir, "goals.csv"))
    data_analyzer = DataAnalyzer()

    tools = {
         'budget_advisor_recommendations': {
            "function": lambda: budget_advisor.generate_spending_recommendations(ltm=long_term_memory),
            "description": "Analyzes budget status based on current month's expenses from memory and provides recommendations.",
            "parameters": {}
        },
        'category_manager_categorize': {
            "function": category_manager.categorize_transaction,
            "description": "Categorizes a single transaction based on description using rules and potentially LLM.",
            "parameters": {"description": "str", "amount": "float"} # Ensure CM expects amount if defined here
        },
        'goal_tracker_create': {
            "function": goal_tracker.create_goal,
            "description": "Creates a new financial goal. Requires name, category, target_amount, target_date (YYYY-MM-DD). Optional: priority, initial_amount, notes.",
            "parameters": {"name": "str", "category": "str", "target_amount": "float", "target_date": "str", "priority": "str", "initial_amount": "float", "notes": "str"}
        },
        'goal_tracker_progress': {
            "function": goal_tracker.update_progress,
            "description": "Updates progress on a financial goal.",
            "parameters": {"goal_id": "str", "new_amount": "float"}
        },
        'goal_tracker_list': {
             "function": goal_tracker.list_goals,
             "description": "Lists financial goals, optionally filtered by status (e.g. 'active'), category, or priority.",
             "parameters": {"status": "Optional[str]", "category": "Optional[str]", "priority": "Optional[str]"}
        },
        'goal_tracker_details': {
             "function": goal_tracker.get_goal,
             "description": "Gets detailed information about a specific financial goal using its ID (e.g., GOAL-1).",
             "parameters": {"goal_id": "str"}
         },
        'data_analyzer_report': {
            "function": lambda start_date=None, end_date=None: data_analyzer.generate_spending_report_from_ltm(ltm=long_term_memory, start_date=start_date, end_date=end_date),
            "description": "Generates a comprehensive spending report for a specified date range (use YYYY-MM-DD format).",
            "parameters": {"start_date": "Optional[str]", "end_date": "Optional[str]"}
        },
        'budget_advisor_set_income': {
            "function": budget_advisor.set_income,
            "description": "Sets the user's total monthly income amount.",
            "parameters": {"amount": "float"}
        },
        'budget_advisor_set_category_budget': {
            "function": budget_advisor.set_category_budget,
            "description": "Sets the monthly budget amount for a specific spending category.",
            "parameters": {"category": "str", "amount": "float"}
        },
        # Add other necessary budget_advisor tools like get_income, get_category_budget etc.
        'budget_advisor_get_income': {
            "function": budget_advisor.get_income,
            "description": "Retrieves the current monthly income setting.",
            "parameters": {}
        },
        'budget_advisor_get_category_budget': {
            "function": budget_advisor.get_category_budget,
            "description": "Retrieves the budget amount for a specific category.",
            "parameters": {"category": "str"}
        }
    }

    agent = FinancialAgent(
        tools=tools,
        llm_manager=llm_manager,
        long_term_memory=long_term_memory
    )

    try:
        improvement_engine = SelfImprovementEngine(memory=long_term_memory)
        agent.add_tool(
            tool_name='self_improvement_analyze',
            tool_func=improvement_engine.generate_improvements,
            params={}
        )
        logger.info("Self-improvement tool added.")
    except Exception as e:
        logger.error(f"Failed to initialize or add self-improvement engine: {e}")

    logger.info("Agent initialized successfully.")
    return agent, long_term_memory, category_manager


if __name__ == "__main__":
    agent, ltm, cm = initialize_agent()

    # Define path to your ORIGINAL transactions CSV
    raw_transactions_csv_path = os.path.join("data", "transactions", "bank_statement.csv") 

    # Load initial expenses
    load_expenses_from_csv(ltm, cm, raw_transactions_csv_path)

    print("\n===== Financial Agent Ready =====")
    print("Type your financial task (e.g., 'Create savings goal for car downpayment $5000 by 2025-10-31', 'List active goals', 'Generate spending report for last month') or type 'quit' to exit.")

    while True:
        try:
            user_input = input("\n> ")
            if user_input.lower() in ["quit", "exit"]:
                print("Exiting agent...")
                break

            if not user_input.strip(): # Handle empty input
                continue

            task = user_input
            logger.info(f"Running agent with task: '{task}'")

            # --- Run the agent ---
            # Consider increasing max_steps if complex tasks require more actions
            agent_result = agent.run(task_description=task, max_steps=15)

         
            print("\n--- Agent Result ---")
            status = agent_result.get("status", "unknown")
            summary = agent_result.get("summary", "No summary provided.")
            results_list = agent_result.get("results", [])

            print(f"Task Status: {status.upper()}")

            
            print(f"Summary: {summary}")

            
            if status == "completed" and results_list:
                 final_step_result = results_list[-1]
                 if final_step_result.get("status") == "success":
                      print("\nFinal Step Tool Result:")
                      # Pretty print the 'result' part of the last successful step
                      print(json.dumps(final_step_result.get("result"), indent=2))

            elif status != "completed":
                 
                 if results_list:
                     last_step_result = results_list[-1]
                     if last_step_result.get("status") == "error":
                         print(f"Error in last step: {last_step_result.get('error')}")

            print("--------------------\n")


        except KeyboardInterrupt:
            print("\nKeyboard interrupt received. Exiting.")
            break
        except Exception as e:
            logger.error(f"An unexpected error occurred in the main loop: {e}", exc_info=True)
            print("An unexpected error occurred. Check logs. Exiting.")
            break # Exit loop on unexpected error

    # --- Shutdown ---
    if agent:
        agent.graceful_shutdown()
    print("Agent shutdown complete.")